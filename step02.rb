# 問題2: ダイクストラ法 - 最短経路のコスト (paizaランク A 相当)

require "byebug"

class Maze
  VY = [-1, 0, 1, 0]
  VX = [0, 1, 0, -1]
  OBSTACLE = "1"

  def initialize(size:, start:, goal:, maze_data:)
    @size = size
    @start = start
    @goal = goal
    @maze_data = maze_data
  end

  def moving_cost(sy = @start[:y], sx = @start[:x], gy = @goal[:y], gx = @goal[:x])
    # 無効な引数なら nil を返す
    return unless valid_range?(sy, sx) && valid_range?(gy, gx) \
      && @maze_data[sy][sx] != OBSTACLE \
      && @maze_data[gy][gx] != OBSTACLE

    # 探索初期化
    queue = [[sy, sx, 1]]
    close = []
    searched_data = Array.new(@size[:h]).map { Array.new(@size[:w]) }

    # 幅優先探索
    while !queue.empty?
      # queue先頭から探索位置を取り出す
      y, x, cost = queue.shift
      # 探索位置が障害物なら探索済みデータに-1を代入してスキップ
      if @maze_data[y][x] == OBSTACLE
        searched_data[y][x] = -1
        next
        # 探索位置が通行可能なら探索済みデータにcostを代入
      else
        searched_data[y][x] = cost
      end
      # 探索位置がゴールだったらcostと探索データを返す
      return [cost, searched_data] if y == @goal[:y] && x == @goal[:x]

      # 現在地の隣接4マスを調べる
      cost += 1
      VY.zip(VX).each do |dy, dx|
        ny = y + dy
        nx = x + dx
        # 有効範囲内かつ未探索なら探索予定に追加
        queue << [ny, nx, cost] if valid_range?(ny, nx) && searched_data[ny][nx].nil?
      end
    end
    # ゴール出来なかったら-1を返す
    [-1, searched_data]
  end

  # 迷路内か？
  def valid_range?(y, x)
    (0...@size[:h]).include?(y) && (0...@size[:w]).include?(x)
  end
end

def solve(input_data)
  h, w = input_data.shift.split.map(&:to_i)
  maze_data = input_data.each.map { |line| line.split }
  params = { size: { h: h, w: w },
             start: { y: 0, x: 0 },
             goal: { y: h - 1, x: w - 1 },
             maze_data: maze_data }
  byebug
  maze = Maze.new(**params)
  maze.moving_cost
end

# データ入力
in1 = <<~"EOS"
  3 6
  0 0 1 0 0 0
  1 0 1 0 1 0
  0 0 0 0 1 0
EOS
# out1 = 12

in2 = <<~"EOS"
  10 10
  0 0 0 1 0 1 0 0 0 0
  1 0 1 0 0 0 0 0 0 0
  0 0 0 1 0 1 1 1 1 1
  0 0 0 0 0 0 0 0 0 0
  1 1 1 0 1 0 1 1 1 1
  0 0 0 0 0 0 1 0 0 0
  0 1 1 1 1 1 1 1 1 0
  0 0 0 0 1 0 1 0 0 0
  1 1 1 0 0 0 1 0 1 0
  0 0 0 0 1 0 0 0 1 0
EOS

cost, searched_data = solve(in2.split("\n"))
unless cost.nil?
  puts cost
  searched_data.each { |line| p line }
else
  puts "無効なデータが入力されました"
end
#solve(readlines.map(&:chomp))

=begin
問題2: ダイクストラ法 - 最短経路のコスト (paizaランク A 相当)

下記の問題をプログラミングしてみよう！
グリッド状の盤面で上下左右の移動を繰り返して、左上のスタートから右下のゴールまで
移動するときに通るマスのコストの合計の最小値を求めてください。

※この問題は、paiza開発日誌で詳しく解説しています

▼下記解答欄にコードを記入してみよう

入力される値
h w
t_{0,0} t_{0,1} ... t_{0,w-1}
t_{1,0} t_{1,1} ... t_{1,w-1}
...
t_{h-1,0} t_{h-1,1} ... t_{h-1,w-1}

・1 行目には盤面の行数を表す h , 盤面の列数を表す w が与えられます。
・続く h 行の各行では i 行目 (0 ≦ i < h) には、盤面が与えられます。
・t_{i,j} は i 行目の j 列目のコストです。

入力値最終行の末尾に改行が１つ入ります。
文字列は標準入力から渡されます。

期待する出力
コストの合計の最小値を 1 行で出力してください。

条件
すべてのテストケースにおいて、以下の条件をみたします。

・1 ≦ h , w ≦ 20
・0 ≦ t_{i,j} ≦ 100 (0 ≦ i < h, 0 ≦ j < w)

入力例1
3 6
0 3 1 4 1 5
9 2 6 5 3 5
3 9 7 9 3 2

0 > 3 > 1 > 4 > 1 > 3 > 3 > 2

出力例1
17

// ※データの流れのみを記載しています。コードはブログ記事を参照ください。
// <<公開されたらここにURL>>

// 最小コストの答えである17を得るところまでシミュレートしてみます。
// これを一度やっておくと、ダイクストラのコードを書くときのデバッグ力が向上します。
// 難しいと感じた方も大丈夫、実践あるのみです。

// スタート時点ではopenリストには(x, y, cost) = (0, 0, 0)の状態が1つだけ入っています。

open: [(0, 0, 0)] closed: {}

// openリストから(0, 0, 0)を取り出し、この状態から右へ移動して(1, 0, 3)という状態を、
下へ移動して(0, 1, 9)という状態を作ってキューに追加します。
// (x, y) = (0, 0)は使用済みとしてclosedリストに追加します。

open: [(1, 0, 3), (0, 1, 9)] closed: {(0, 0)}

// openリストからコストの一番小さな(1, 0, 3)を取り出し、
右移動の(2, 0, 4)、左移動の(0, 0, 3)、下移動の(1, 1, 5)を作ります。
 closedリストには(1, 0)を追加します。

open: [(0, 1, 9), (2, 0, 4), (0, 0, 3), (1, 1, 5)] closed: {(0, 0), (1, 0)}

// openリストからコストの一番小さな(0, 0, 3)を取り出しますが、(0, 0)がclosedリストにすでに存在するので、何もしません。

open: [(0, 1, 9), (2, 0, 4), (1, 1, 5)] closed: {(0, 0), (1, 0)}

// openリストからコストの一番小さな(2, 0, 4)を取り出し、(3, 0, 8), (1, 0, 4), (2, 1, 10)を作ります。 closedリストには(2, 0)を追加します。

open: [(0, 1, 9), (1, 1, 5), (3, 0, 8), (1, 0, 4), (2, 1, 10)] closed: {(0, 0), (1, 0), (2, 0)}

// openリストからコストの一番小さな(1, 0, 4)を取り出しますが、(1, 0)がclosedリストにすでに存在するので、何もしません。

open: [(0, 1, 9), (1, 1, 5), (3, 0, 8), (2, 1, 10)] closed: {(0, 0), (1, 0), (2, 0)}

// openリストからコストの一番小さな(1, 1, 5)を取り出し、(2, 1, 11), (1, 0, 7), (0, 1, 14), (1, 2, 14)を作ります。 closedリストには(1, 1)を追加します。

open: [(0, 1, 9), (3, 0, 8), (2, 1, 10), (2, 1, 11), (1, 0, 7), (0, 1, 14), (1, 2, 14)] closed: {(0, 0), (1, 0), (2, 0), (1, 1)}

// openリストからコストの一番小さな(1, 0, 7)を取り出ますが、(1, 0)がclosedリストにすでに存在するので、何もしません。

open: [(0, 1, 9), (3, 0, 8), (2, 1, 10), (2, 1, 11), (0, 1, 14), (1, 2, 14)] closed: {(0, 0), (1, 0), (2, 0), (1, 1)}

// openリストからコストの一番小さな(3, 0, 8)を取り出し、(4, 0, 9), (2, 0, 9), (3, 1, 13)を作ります。 closedリストには(3, 0)を追加します。

open: [(0, 1, 9), (2, 1, 10), (2, 1, 11), (0, 1, 14), (1, 2, 14), (4, 0, 9), (2, 0, 9), (3, 1, 13)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0)}

// openリストからコストの一番小さな(0, 1, 9)を取り出し、(1, 1, 11), (0, 0, 9), (0, 2, 12)を作ります。 closedリストには(0, 1)を追加します。

open: [(2, 1, 10), (2, 1, 11), (0, 1, 14), (1, 2, 14), (4, 0, 9), (2, 0, 9), (3, 1, 13), (1, 1, 11), (0, 0, 9), (0, 2, 12)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1)}

// openリストからコストの一番小さな(4, 0, 9)を取り出し、(5, 0, 14), (3, 0, 13), (4, 1, 12)を作ります。 closedリストには(4, 0)を追加します。

open: [(2, 1, 10), (2, 1, 11), (0, 1, 14), (1, 2, 14), (2, 0, 9), (3, 1, 13), (1, 1, 11), (0, 0, 9), (0, 2, 12), (5, 0, 14), (3, 0, 13), (4, 1, 12)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0)}

// openリストからコストの一番小さな(2, 0, 9)を取り出しますが、(2, 0)がclosedリストにすでに存在するので、何もしません。

open: [(2, 1, 10), (2, 1, 11), (0, 1, 14), (1, 2, 14), (3, 1, 13), (1, 1, 11), (0, 0, 9), (0, 2, 12), (5, 0, 14), (3, 0, 13), (4, 1, 12)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0)}

// openリストからコストの一番小さな(0, 0, 9)を取り出しますが、(0, 0)がclosedリストにすでに存在するので、何もしません。

open: [(2, 1, 10), (2, 1, 11), (0, 1, 14), (1, 2, 14), (3, 1, 13), (1, 1, 11), (0, 2, 12), (5, 0, 14), (3, 0, 13), (4, 1, 12)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0)}

// openリストからコストの一番小さな(2, 1, 10)を取り出し、(3, 1, 15), (2, 0, 11), (1, 1, 12), (2, 2, 17)を作ります。 closedリストには(2, 1)を追加します。

open: [(2, 1, 11), (0, 1, 14), (1, 2, 14), (3, 1, 13), (1, 1, 11), (0, 2, 12), (5, 0, 14), (3, 0, 13), (4, 1, 12), (3, 1, 15), (2, 0, 11), (1, 1, 12), (2, 2, 17)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1)}

// openリストからコストの一番小さな(2, 1, 11)を取り出しますが、(2, 1)がclosedリストにすでに存在するので、何もしません。

open: [(0, 1, 14), (1, 2, 14), (3, 1, 13), (1, 1, 11), (0, 2, 12), (5, 0, 14), (3, 0, 13), (4, 1, 12), (3, 1, 15), (2, 0, 11), (1, 1, 12), (2, 2, 17)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1)}

// openリストからコストの一番小さな(1, 1, 11)を取り出しますが、(1, 1)がclosedリストにすでに存在するので、何もしません。

open: [(0, 1, 14), (1, 2, 14), (3, 1, 13), (0, 2, 12), (5, 0, 14), (3, 0, 13), (4, 1, 12), (3, 1, 15), (2, 0, 11), (1, 1, 12), (2, 2, 17)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1)}

// openリストからコストの一番小さな(2, 0, 11)を取り出しますが、(2, 0)がclosedリストにすでに存在するので、何もしません。

open: [(0, 1, 14), (1, 2, 14), (3, 1, 13), (0, 2, 12), (5, 0, 14), (3, 0, 13), (4, 1, 12), (3, 1, 15), (1, 1, 12), (2, 2, 17)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1)}

// openリストからコストの一番小さな(0, 2, 12)を取り出し、(0, 1, 21), (1, 2, 21)を作ります。 closedリストには(0, 2)を追加します。

open: [(0, 1, 14), (1, 2, 14), (3, 1, 13), (5, 0, 14), (3, 0, 13), (4, 1, 12), (3, 1, 15), (1, 1, 12), (2, 2, 17), (0, 1, 21), (1, 2, 21)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2)}

// openリストからコストの一番小さな(4, 1, 12)を取り出し、(5, 1, 17), (4, 0, 15), (3, 1, 17), (4, 2, 15)を作ります。 closedリストには(4, 1)を追加します。

open: [(0, 1, 14), (1, 2, 14), (3, 1, 13), (5, 0, 14), (3, 0, 13), (3, 1, 15), (1, 1, 12), (2, 2, 17), (0, 1, 21), (1, 2, 21), (5, 1, 17), (4, 0, 15), (3, 1, 17), (4, 2, 15)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1)}

// openリストからコストの一番小さな(1, 1, 12)を取り出しますが、(1, 1)がclosedリストにすでに存在するので、何もしません。

open: [(0, 1, 14), (1, 2, 14), (3, 1, 13), (5, 0, 14), (3, 0, 13), (3, 1, 15), (2, 2, 17), (0, 1, 21), (1, 2, 21), (5, 1, 17), (4, 0, 15), (3, 1, 17), (4, 2, 15)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1)}

// openリストからコストの一番小さな(3, 1, 13)を取り出し、(4, 1, 16), (3, 0, 17), (2, 1, 19), (3, 2, 22)を作ります。 closedリストには(3, 1)を追加します。

open: [(0, 1, 14), (1, 2, 14), (5, 0, 14), (3, 0, 13), (3, 1, 15), (2, 2, 17), (0, 1, 21), (1, 2, 21), (5, 1, 17), (4, 0, 15), (3, 1, 17), (4, 2, 15), (4, 1, 16), (3, 0, 17), (2, 1, 19), (3, 2, 22)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1), (3, 1)}

// openリストからコストの一番小さな(3, 0, 13)を取り出しますが、(3, 0)がclosedリストにすでに存在するので、何もしません。

open: [(0, 1, 14), (1, 2, 14), (5, 0, 14), (3, 1, 15), (2, 2, 17), (0, 1, 21), (1, 2, 21), (5, 1, 17), (4, 0, 15), (3, 1, 17), (4, 2, 15), (4, 1, 16), (3, 0, 17), (2, 1, 19), (3, 2, 22)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1), (3, 1)}

// openリストからコストの一番小さな(0, 1, 14)を取り出しますが、(0, 1)がclosedリストにすでに存在するので、何もしません。

open: [(1, 2, 14), (5, 0, 14), (3, 1, 15), (2, 2, 17), (0, 1, 21), (1, 2, 21), (5, 1, 17), (4, 0, 15), (3, 1, 17), (4, 2, 15), (4, 1, 16), (3, 0, 17), (2, 1, 19), (3, 2, 22)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1), (3, 1)}

// openリストからコストの一番小さな(1, 2, 14)を取り出し、(2, 2, 21), (1, 1, 16), (0, 2, 17)を作ります。 closedリストには(1, 2)を追加します。

open: [(5, 0, 14), (3, 1, 15), (2, 2, 17), (0, 1, 21), (1, 2, 21), (5, 1, 17), (4, 0, 15), (3, 1, 17), (4, 2, 15), (4, 1, 16), (3, 0, 17), (2, 1, 19), (3, 2, 22), (2, 2, 21), (1, 1, 16), (0, 2, 17)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1), (3, 1), (1, 2)}

// openリストからコストの一番小さな(5, 0, 14)を取り出し、(4, 0, 15), (5, 1, 19)を作ります。 closedリストには(5, 0)を追加します。

open: [(3, 1, 15), (2, 2, 17), (0, 1, 21), (1, 2, 21), (5, 1, 17), (4, 0, 15), (3, 1, 17), (4, 2, 15), (4, 1, 16), (3, 0, 17), (2, 1, 19), (3, 2, 22), (2, 2, 21), (1, 1, 16), (0, 2, 17), (4, 0, 15), (5, 1, 19)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1), (3, 1), (1, 2), (5, 0)}

// openリストからコストの一番小さな(3, 1, 15)を取り出しますが、(3, 1)がclosedリストにすでに存在するので、何もしません。

open: [(2, 2, 17), (0, 1, 21), (1, 2, 21), (5, 1, 17), (4, 0, 15), (3, 1, 17), (4, 2, 15), (4, 1, 16), (3, 0, 17), (2, 1, 19), (3, 2, 22), (2, 2, 21), (1, 1, 16), (0, 2, 17), (4, 0, 15), (5, 1, 19)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1), (3, 1), (1, 2), (5, 0)}

// openリストからコストの一番小さな(4, 0, 14)を取り出しますが、(4, 0)がclosedリストにすでに存在するので、何もしません。

open: [(2, 2, 17), (0, 1, 21), (1, 2, 21), (5, 1, 17), (3, 1, 17), (4, 2, 15), (4, 1, 16), (3, 0, 17), (2, 1, 19), (3, 2, 22), (2, 2, 21), (1, 1, 16), (0, 2, 17), (4, 0, 15), (5, 1, 19)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1), (3, 1), (1, 2), (5, 0)}

// openリストからコストの一番小さな(4, 2, 15)を取り出し、(5, 2, 17), (4, 1, 18), (3, 2, 24)を作ります。 closedリストには(4, 2)を追加します。 (5, 2, 17)はぶっちゃけ知りたい答えの状態なんですが、まだ他に良い答えがあるかもしれませんので答えは確定せず、まだ続きます。

open: [(2, 2, 17), (0, 1, 21), (1, 2, 21), (5, 1, 17), (3, 1, 17), (4, 1, 16), (3, 0, 17), (2, 1, 19), (3, 2, 22), (2, 2, 21), (1, 1, 16), (0, 2, 17), (4, 0, 15), (5, 1, 19), (5, 2, 17), (4, 1, 18), (3, 2, 24)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1), (3, 1), (1, 2), (5, 0), (4, 2)}

// openリストからコストの一番小さな(4, 0, 15)を取り出しますが、(4, 0)がclosedリストにすでに存在するので、何もしません。

open: [(2, 2, 17), (0, 1, 21), (1, 2, 21), (5, 1, 17), (3, 1, 17), (4, 1, 16), (3, 0, 17), (2, 1, 19), (3, 2, 22), (2, 2, 21), (1, 1, 16), (0, 2, 17), (5, 1, 19), (5, 2, 17), (4, 1, 18), (3, 2, 24)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1), (3, 1), (1, 2), (5, 0), (4, 2)}

// openリストからコストの一番小さな(4, 1, 16)を取り出しますが、(4, 1)がclosedリストにすでに存在するので、何もしません。

open: [(2, 2, 17), (0, 1, 21), (1, 2, 21), (5, 1, 17), (3, 1, 17), (3, 0, 17), (2, 1, 19), (3, 2, 22), (2, 2, 21), (1, 1, 16), (0, 2, 17), (5, 1, 19), (5, 2, 17), (4, 1, 18), (3, 2, 24)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1), (3, 1), (1, 2), (5, 0), (4, 2)}

// openリストからコストの一番小さな(1, 1, 16)を取り出しますが、(1, 1)がclosedリストにすでに存在するので、何もしません。

open: [(2, 2, 17), (0, 1, 21), (1, 2, 21), (5, 1, 17), (3, 1, 17), (3, 0, 17), (2, 1, 19), (3, 2, 22), (2, 2, 21), (0, 2, 17), (5, 1, 19), (5, 2, 17), (4, 1, 18), (3, 2, 24)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1), (3, 1), (1, 2), (5, 0), (4, 2)}

// openリストからコストの一番小さな(5, 1, 17)を取り出し、(5, 0, 22), (4, 1, 20), (5, 2, 19)を作ります。 closedリストには(5, 1)を追加します。 ゴールにたどり着く別の状態(5, 2, 19)が見つかりましたが、よりコストの小さい(5, 2, 17)が先に処理されるはずです。続きます。

open: [(2, 2, 17), (0, 1, 21), (1, 2, 21), (3, 1, 17), (3, 0, 17), (2, 1, 19), (3, 2, 22), (2, 2, 21), (0, 2, 17), (5, 1, 19), (5, 2, 17), (4, 1, 18), (3, 2, 24)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1), (3, 1), (1, 2), (5, 0), (4, 2)}

// openリストからコストの一番小さな(2, 2, 17)を取り出し、(3, 2, 26), (2, 1, 23), (1, 2, 26)を作ります。 closedリストには(2, 2)を追加します。

open: [(0, 1, 21), (1, 2, 21), (3, 1, 17), (3, 0, 17), (2, 1, 19), (3, 2, 22), (2, 2, 21), (0, 2, 17), (5, 1, 19), (5, 2, 17), (4, 1, 18), (3, 2, 24), (3, 2, 26), (2, 1, 23), (1, 2, 26)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1), (3, 1), (1, 2), (5, 0), (4, 2), (2, 2)}

// openリストからコストの一番小さな(3, 1, 17)を取り出しますが、(3, 1)がclosedリストにすでに存在するので、何もしません。

open: [(0, 1, 21), (1, 2, 21), (3, 0, 17), (2, 1, 19), (3, 2, 22), (2, 2, 21), (0, 2, 17), (5, 1, 19), (5, 2, 17), (4, 1, 18), (3, 2, 24), (3, 2, 26), (2, 1, 23), (1, 2, 26)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1), (3, 1), (1, 2), (5, 0), (4, 2), (2, 2)}

// openリストからコストの一番小さな(3, 0, 17)を取り出しますが、(3, 0)がclosedリストにすでに存在するので、何もしません。

open: [(0, 1, 21), (1, 2, 21), (2, 1, 19), (3, 2, 22), (2, 2, 21), (0, 2, 17), (5, 1, 19), (5, 2, 17), (4, 1, 18), (3, 2, 24), (3, 2, 26), (2, 1, 23), (1, 2, 26)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1), (3, 1), (1, 2), (5, 0), (4, 2), (2, 2)}

// openリストからコストの一番小さな(0, 2, 17)を取り出しますが、(0, 2)がclosedリストにすでに存在するので、何もしません。

open: [(0, 1, 21), (1, 2, 21), (2, 1, 19), (3, 2, 22), (2, 2, 21), (5, 1, 19), (5, 2, 17), (4, 1, 18), (3, 2, 24), (3, 2, 26), (2, 1, 23), (1, 2, 26)] closed: {(0, 0), (1, 0), (2, 0), (1, 1), (3, 0), (0, 1), (4, 0), (2, 1), (0, 2), (4, 1), (3, 1), (1, 2), (5, 0), (4, 2), (2, 2)}

// openリストからコストの一番小さな(5, 2, 17)を取り出します。 (x, y) = (5, 2)はゴールの位置です。 よって、(5, 2)の位置に対応するコストの17を答えとして返します。
=end
